// All examples will start by including "@topaz.core", which is a
// built-in package for topaz symbols and classes.
#include "@topaz.core"

// In gravity, topaz implements its classes as proper gravity classes.
// To demonstrate this, we will make our own entity class, based 
// off of the base topaz entity.
//
// As a review, entities are the basic building blocks within 
// a topaz program. They are updated every frame once the engine is started 
// and can contain their own properties and components.
//
// Typically, entities will be extended in 2 ways:
//  - Populating an update function such as onStep or onDraw, which will 
//    be called every frame.
//  - Attaching components to the entity to extend its behavior in reusable ways.
//
//
// The entity we want to create will:
//  - Show a colored rectangle on the screen
//  - Change the rotation of the rectangle 
//    every frame.
class Rectangle : Topaz.Entity {
    // In gravity, classes can have their own private 
    // variables, which is important to use to manage 
    // complexity and keep code as maintainable as possible.
    // 
    // Variables that are to be used by functions must be
    // declared before theyre used.
    private var visual;



    // Every custom entity class can have an optional 
    // "onReady" function. This can be used to initialize 
    // the instance. In our case we will use it to 
    // set up the visual
    func onReady() {

        // Shape2D is the basic component for drawing 2D shapes.
        // It can be formed into any shape, but we will stick with 
        // a basic rectangle.
        visual = Topaz.Shape2D();


        // This changes the shape into a 200 by 200 rectangle.
        visual.formRectangle(200, 200);


        // By default, the center of a Shape2D is the top-left 
        // of the shape. Since rotation is about the center,
        // the set the center to one half of the rectangles span.
        visual.center = Topaz.Vector(100, 100);


        // The color of any Shape2D can be assigned directly. 
        // The string can be a common color name, or a #RRGGBB/AA 
        // formatted hex string.
        visual.color = Topaz.Color("purple");

        // Even though the component has all the information 
        // we want stored within it, the component cannot update itself.
        // We still have to associate it with our entity.
        // This can be done by using the addComponent() function.
        addComponent(visual);
    }


    // Along with components, every entity can have a custom set of 
    // update functions. The most common one is onStep() which is 
    // run every frame.
    func onStep() {
        // Every entity has built-in properties, such as 
        // position, rotation, and scale.
        // Here, we add 0.001, 0.002, and 0.003 degrees to the x, y, and z 
        // rotation respectively every frame. 
        //
        // The position, rotation, and scale properties are vector objects,
        // so to update them, you actually replace them with new vectors.
        rotation = rotation + Topaz.Vector(0.0001, 0.0002, 0.0003);
    }
}



// Now that the entity has been defined, we need to actually use it.
//
// In gravity, the main() function will always be called first.
// We can use this to instantiate our rectangle
func main() {

    // This instantiates the class we've defined.
    var entity = Rectangle();    


    // The default position for an entity is 0,0,0,
    // so we'll want to move it. Note how we set the center 
    // of the Shape2D component already: topaz is inherently 
    // hierarchical: objects will use the position / rotation / scale 
    // of things that they are attached to. 
    entity.position = Topaz.Vector(100, 100);
    

    // Even though we've created the our rectangle entity,
    // creating the entity on its own doesnt do much.
    // Much like when we created the component, 
    // topaz still needs to be aware of what to do with it.
    //
    // Topaz manages entities in the form of a tree, so     
    // entities naturally can have children entities 
    // and a parent entity. The root is the very base of the tree.
    // Since we are only making one entity, we will just 
    // set the entity has the root itself.
    //
    // Normally, the root will be more symbolic than physical,
    // think of a "room" in a game.
    //
    // The tree can be manipulated while running to control 
    // runtime efficiency for the program.
    //
    Topaz.root = entity;
}





